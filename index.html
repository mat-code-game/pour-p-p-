<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pac-Man Mobile</title>
  <style>
    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }
    
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      font-family: 'Courier New', monospace;
      background: radial-gradient(circle at top, #020617, #0f172a);
      color: #e5e7eb;
      overflow: hidden;
      padding: 10px;
    }

    h1 {
      margin: 10px 0;
      font-size: 24px;
      color: #facc15;
      letter-spacing: 2px;
      text-shadow: 0 0 20px #facc15;
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { text-shadow: 0 0 20px #facc15; }
      to { text-shadow: 0 0 30px #facc15, 0 0 40px #facc15; }
    }

    #stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      width: 100%;
      max-width: 400px;
      margin-bottom: 10px;
    }

    .stat {
      padding: 6px 10px;
      background: rgba(29, 78, 216, 0.3);
      border-radius: 6px;
      border: 2px solid #1d4ed8;
      text-align: center;
    }

    .stat-label {
      color: #94a3b8;
      font-size: 10px;
      display: block;
    }

    .stat-value {
      color: #facc15;
      font-size: 16px;
      font-weight: bold;
    }

    .lives-container {
      display: flex;
      gap: 4px;
      justify-content: center;
      align-items: center;
    }

    .life-icon {
      width: 16px;
      height: 16px;
      background: #facc15;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 8px #facc15;
    }

    #game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      flex-grow: 1;
      justify-content: center;
    }

    #game {
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(250, 204, 21, 0.3);
      border: 3px solid #1d4ed8;
      max-width: 100%;
    }

    canvas {
      background: #020617;
      display: block;
      max-width: 100%;
      height: auto;
    }

    #pause-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      color: #facc15;
      font-weight: bold;
      text-shadow: 0 0 20px #facc15;
      z-index: 10;
    }

    #pause-overlay.active {
      display: flex;
    }

    #message {
      margin: 10px 0;
      font-size: 14px;
      min-height: 20px;
      color: #facc15;
      font-weight: bold;
      text-align: center;
    }

    #game-layout {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      justify-content: center;
      width: 100%;
      max-width: 1000px;
      margin-top: 10px;
    }

    #powers-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 180px;
    }

    #controls-mobile {
      padding: 15px;
      background: rgba(29, 78, 216, 0.2);
      border-radius: 8px;
      border: 2px solid #1d4ed8;
      min-width: 220px;
    }

    #dpad {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap: 8px;
      max-width: 200px;
      margin: 0 auto;
    }

    .dpad-btn {
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #1d4ed8, #2563eb);
      border: 3px solid #3b82f6;
      border-radius: 12px;
      color: #facc15;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 15px rgba(29, 78, 216, 0.4);
      touch-action: manipulation;
    }

    .dpad-btn:active {
      background: linear-gradient(135deg, #2563eb, #3b82f6);
      transform: scale(0.95);
      box-shadow: 0 2px 8px rgba(29, 78, 216, 0.6);
    }

    .dpad-btn.center {
      background: linear-gradient(135deg, #f59e0b, #facc15);
      border-color: #fbbf24;
    }

    .dpad-btn.center:active {
      background: linear-gradient(135deg, #fbbf24, #fde047);
    }

    #up-btn { grid-column: 2; grid-row: 1; }
    #left-btn { grid-column: 1; grid-row: 2; }
    #pause-btn { grid-column: 2; grid-row: 2; font-size: 20px; }
    #right-btn { grid-column: 3; grid-row: 2; }
    #down-btn { grid-column: 2; grid-row: 3; }

    .action-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
    }

    .action-btn {
      padding: 10px 20px;
      background: linear-gradient(135deg, #1d4ed8, #2563eb);
      border: 2px solid #3b82f6;
      border-radius: 8px;
      color: #facc15;
      font-size: 14px;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(29, 78, 216, 0.4);
      touch-action: manipulation;
    }

    .action-btn:active {
      background: linear-gradient(135deg, #2563eb, #3b82f6);
      transform: translateY(2px);
    }

    .power-mini {
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid rgba(29, 78, 216, 0.5);
      border-radius: 6px;
      padding: 8px;
      font-size: 11px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .power-mini-icon {
      font-size: 18px;
    }

    .power-mini-text {
      flex: 1;
    }

    .power-mini-name {
      font-weight: bold;
      display: block;
      margin-bottom: 2px;
    }

    .power-mini-duration {
      color: #64748b;
      font-size: 9px;
    }

    .power-invincible { color: #facc15; }
    .power-speed { color: #22c55e; }
    .power-shield { color: #3b82f6; }
    .power-freeze { color: #a855f7; }

    .combo-popup {
      position: absolute;
      font-size: 20px;
      font-weight: bold;
      color: #22c55e;
      text-shadow: 0 0 10px #22c55e;
      pointer-events: none;
      animation: popupFloat 1s ease-out forwards;
      z-index: 5;
    }

    @keyframes popupFloat {
      0% {
        opacity: 1;
        transform: translateY(0) scale(0.5);
      }
      100% {
        opacity: 0;
        transform: translateY(-40px) scale(1.5);
      }
    }

    /* Responsive mobile */
    @media (max-width: 768px) {
      #game-layout {
        flex-direction: column;
        align-items: center;
      }

      #powers-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
      }

      #controls-mobile {
        width: 100%;
        max-width: 400px;
        margin-top: 15px;
      }
    }

    /* Orientation paysage */
    @media screen and (orientation: landscape) and (max-height: 500px) {
      body {
        flex-direction: row;
        padding: 5px;
      }

      h1 {
        position: absolute;
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 18px;
        margin: 0;
      }

      #stats {
        position: absolute;
        top: 35px;
        left: 50%;
        transform: translateX(-50%);
        grid-template-columns: repeat(4, 1fr);
        max-width: 500px;
        gap: 5px;
      }

      .stat {
        padding: 4px 6px;
      }

      .stat-label {
        font-size: 8px;
      }

      .stat-value {
        font-size: 12px;
      }

      #game-container {
        margin-top: 70px;
      }

      #game {
        max-height: calc(100vh - 80px);
      }

      canvas {
        max-height: calc(100vh - 80px);
      }

      #controls-mobile {
        position: fixed;
        bottom: 5px;
        right: 5px;
        max-width: 250px;
        padding: 10px;
      }

      #dpad {
        gap: 5px;
        max-width: 160px;
      }

      .dpad-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      #powers-info {
        display: none;
      }

      #message {
        position: absolute;
        bottom: 5px;
        left: 5px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <h1>PAC-MAN MOBILE</h1>
  
  <div id="stats">
    <div class="stat">
      <span class="stat-label">SCORE</span>
      <div class="stat-value" id="score-value">0</div>
    </div>
    <div class="stat">
      <span class="stat-label">NIVEAU</span>
      <div class="stat-value" id="level-value">1</div>
    </div>
    <div class="stat">
      <span class="stat-label">RECORD</span>
      <div class="stat-value" id="high-score-value">0</div>
    </div>
    <div class="stat">
      <span class="stat-label">VIES</span>
      <div class="lives-container" id="lives-container"></div>
    </div>
  </div>

  <div id="game-layout">
    <!-- Pouvoirs √† gauche -->
    <div id="powers-info">
      <div class="power-mini">
        <span class="power-mini-icon power-invincible">‚ö°</span>
        <div class="power-mini-text">
          <span class="power-mini-name power-invincible">Invincibilit√©</span>
          <span class="power-mini-duration">8s</span>
        </div>
      </div>
      <div class="power-mini">
        <span class="power-mini-icon power-speed">üöÄ</span>
        <div class="power-mini-text">
          <span class="power-mini-name power-speed">Vitesse</span>
          <span class="power-mini-duration">6s</span>
        </div>
      </div>
      <div class="power-mini">
        <span class="power-mini-icon power-shield">üõ°Ô∏è</span>
        <div class="power-mini-text">
          <span class="power-mini-name power-shield">Bouclier</span>
          <span class="power-mini-duration">10s</span>
        </div>
      </div>
      <div class="power-mini">
        <span class="power-mini-icon power-freeze">‚ùÑÔ∏è</span>
        <div class="power-mini-text">
          <span class="power-mini-name power-freeze">Freeze</span>
          <span class="power-mini-duration">5s</span>
        </div>
      </div>
    </div>

    <!-- Jeu au centre -->
    <div id="game-container">
      <div id="game">
        <canvas id="canvas" width="448" height="352"></canvas>
      </div>
      <div id="pause-overlay">‚è∏ PAUSE</div>
    </div>

    <!-- Contr√¥les √† droite -->
    <div id="controls-mobile">
      <div id="dpad">
        <button class="dpad-btn" id="up-btn">‚ñ≤</button>
        <button class="dpad-btn" id="left-btn">‚óÑ</button>
        <button class="dpad-btn center" id="pause-btn">‚è∏</button>
        <button class="dpad-btn" id="right-btn">‚ñ∫</button>
        <button class="dpad-btn" id="down-btn">‚ñº</button>
      </div>

      <div class="action-buttons">
        <button class="action-btn" id="restart-btn">üîÑ</button>
      </div>
    </div>
  </div>

  <div id="message"></div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score-value");
    const levelEl = document.getElementById("level-value");
    const highScoreEl = document.getElementById("high-score-value");
    const livesContainer = document.getElementById("lives-container");
    const messageEl = document.getElementById("message");
    const pauseOverlay = document.getElementById("pause-overlay");

    // Maps pour diff√©rents niveaux
    // 0: vide, 1: mur, 2: pastille, 3: invincibilit√©, 4: vitesse, 5: bouclier, 6: freeze
    const maps = [
      // Niveau 1
      [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,2,2,1,2,2,2,2,1,2,2,2,1],
        [1,3,1,2,1,2,1,1,2,1,2,1,4,1],
        [1,2,1,2,2,2,2,2,2,2,2,1,2,1],
        [1,2,1,1,1,2,1,1,1,2,1,1,2,1],
        [1,2,2,2,1,2,2,0,2,2,1,2,2,1],
        [1,2,1,2,1,1,2,2,2,1,1,2,1,1],
        [1,2,1,2,2,2,2,2,2,2,2,2,2,1],
        [1,5,1,2,1,1,2,1,1,1,2,1,6,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ],
      // Niveau 2
      [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,2,1,1,1,1,2,1,1,2,1],
        [1,4,1,2,2,2,2,2,2,2,2,1,3,1],
        [1,2,2,2,1,1,2,2,1,1,2,2,2,1],
        [1,2,1,2,2,2,2,0,2,2,2,2,1,1],
        [1,2,1,2,1,1,2,2,2,1,1,2,1,1],
        [1,2,2,2,2,2,2,1,2,2,2,2,2,1],
        [1,5,1,1,2,1,2,2,2,1,2,1,6,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ],
      // Niveau 3
      [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,2,2,2,1,2,2,1,2,2,2,2,1],
        [1,2,1,1,2,1,2,2,1,2,1,1,2,1],
        [1,2,1,3,2,2,2,2,2,2,6,1,2,1],
        [1,2,1,2,1,1,1,1,1,1,2,1,2,1],
        [1,2,2,2,2,2,2,0,2,2,2,2,2,1],
        [1,2,1,2,1,1,1,1,1,1,2,1,2,1],
        [1,2,1,4,2,2,2,2,2,2,5,1,2,1],
        [1,2,1,1,2,1,2,2,1,2,1,1,2,1],
        [1,2,2,2,2,1,2,2,1,2,2,2,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ]
    ];

    // Syst√®me de r√©apparition des power-ups
    const powerUpRespawn = {
      enabled: true,
      respawnTime: 15000,
      collected: new Map()
    };

    const tileSize = 32;
    let currentMap = [];
    let originalMap = [];
    let rows, cols;

    const pacman = {
      row: 5,
      col: 7,
      dir: { x: 0, y: 0 },
      nextDir: { x: 0, y: 0 },
      radius: tileSize / 2 - 4,
      mouthAngle: 0.25,
      mouthOpening: true,
      powered: false,
      powerTimer: 0,
      powerDuration: 8000,
      speed: 1,
      shield: false,
      freeze: false
    };

    const ghosts = [
      { row: 1, col: 1, color: "#ef4444", baseColor: "#ef4444", dir: { x: 1, y: 0 }, stepTimer: 0, name: "Blinky", scatterTarget: {row: 0, col: 13} },
      { row: 1, col: 12, color: "#ec4899", baseColor: "#ec4899", dir: { x: -1, y: 0 }, stepTimer: 0, name: "Pinky", scatterTarget: {row: 0, col: 0} },
      { row: 9, col: 1, color: "#06b6d4", baseColor: "#06b6d4", dir: { x: 1, y: 0 }, stepTimer: 0, name: "Inky", scatterTarget: {row: 10, col: 13} },
      { row: 9, col: 12, color: "#f97316", baseColor: "#f97316", dir: { x: -1, y: 0 }, stepTimer: 0, name: "Clyde", scatterTarget: {row: 10, col: 0} }
    ];

    let score = 0;
    let level = 1;
    let highScore = localStorage.getItem('pacmanHighScore') || 0;
    let lives = 3;
    let totalDots = 0;
    let gameOver = false;
    let paused = false;
    let combo = 0;
    let comboTimer = 0;
    let ghostsEaten = 0;

    const baseGhostDelay = 280;
    const basePacmanDelay = 120;
    let ghostStepDelay = baseGhostDelay;
    let pacmanStepDelay = basePacmanDelay;
    let pacmanStepTimer = 0;
    let lastTime = 0;

    const powerUpTypes = {
      3: { name: 'Invincibilit√©', color: '#facc15', duration: 8000, icon: '‚ö°' },
      4: { name: 'Vitesse', color: '#22c55e', duration: 6000, icon: 'üöÄ' },
      5: { name: 'Bouclier', color: '#3b82f6', duration: 10000, icon: 'üõ°Ô∏è' },
      6: { name: 'Freeze', color: '#a855f7', duration: 5000, icon: '‚ùÑÔ∏è' }
    };

    const sounds = {
      eatDot: () => addPoints(10),
      eatPowerPellet: () => {
        addPoints(50);
        canvas.style.filter = 'brightness(1.5)';
        setTimeout(() => canvas.style.filter = 'brightness(1)', 300);
      },
      eatGhost: (multiplier) => {
        addPoints(200 * multiplier);
        showComboPopup(200 * multiplier);
      },
      death: () => {
        messageEl.textContent = "üíÄ A√Øe ! Vie perdue...";
        setTimeout(() => messageEl.textContent = "", 2000);
      }
    };

    function init() {
      currentMap = JSON.parse(JSON.stringify(maps[Math.min(level - 1, maps.length - 1)]));
      originalMap = JSON.parse(JSON.stringify(currentMap));
      rows = currentMap.length;
      cols = currentMap[0].length;
      
      totalDots = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (currentMap[r][c] === 2) totalDots++;
        }
      }
      
      scoreEl.textContent = score;
      levelEl.textContent = level;
      highScoreEl.textContent = highScore;
      updateLivesDisplay();
      messageEl.textContent = "";
      gameOver = false;
      paused = false;
      
      pacman.row = 5;
      pacman.col = 7;
      pacman.dir = { x: 0, y: 0 };
      pacman.nextDir = { x: 0, y: 0 };
      pacman.powered = false;
      pacman.powerTimer = 0;
      pacman.speed = 1;
      pacman.shield = false;
      pacman.freeze = false;
      
      ghostStepDelay = Math.max(150, baseGhostDelay - (level - 1) * 20);
      pacmanStepDelay = Math.max(80, basePacmanDelay - (level - 1) * 5);
      
      const startPositions = [
        {row: 1, col: 1}, {row: 1, col: 12}, 
        {row: 9, col: 1}, {row: 9, col: 12}
      ];
      ghosts.forEach((ghost, i) => {
        ghost.row = startPositions[i].row;
        ghost.col = startPositions[i].col;
        ghost.stepTimer = 0;
        ghost.color = ghost.baseColor;
      });
      
      pacmanStepTimer = 0;
      combo = 0;
      ghostsEaten = 0;
      powerUpRespawn.collected.clear();
    }

    function updateLivesDisplay() {
      livesContainer.innerHTML = '';
      for (let i = 0; i < lives; i++) {
        const lifeIcon = document.createElement('div');
        lifeIcon.className = 'life-icon';
        livesContainer.appendChild(lifeIcon);
      }
    }

    function addPoints(points) {
      score += points;
      scoreEl.textContent = score;
      
      if (score > highScore) {
        highScore = score;
        highScoreEl.textContent = highScore;
        localStorage.setItem('pacmanHighScore', highScore);
      }
    }

    function showComboPopup(points) {
      const popup = document.createElement('div');
      popup.className = 'combo-popup';
      popup.textContent = `+${points}!`;
      popup.style.left = (pacman.col * tileSize + tileSize / 2) + 'px';
      popup.style.top = (pacman.row * tileSize) + 'px';
      document.getElementById('game').appendChild(popup);
      setTimeout(() => popup.remove(), 1000);
    }

    function drawMap() {
      const currentTime = Date.now();
      
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          let tile = currentMap[r][c];
          const key = `${r}-${c}`;
          
          if (tile === 0 && originalMap[r][c] >= 3 && powerUpRespawn.collected.has(key)) {
            const collectedTime = powerUpRespawn.collected.get(key);
            if (currentTime - collectedTime >= powerUpRespawn.respawnTime) {
              currentMap[r][c] = originalMap[r][c];
              tile = originalMap[r][c];
              powerUpRespawn.collected.delete(key);
            }
          }

          ctx.fillStyle = "#020617";
          ctx.fillRect(c * tileSize, r * tileSize, tileSize, tileSize);

          if (tile === 1) {
            const gradient = ctx.createLinearGradient(
              c * tileSize, r * tileSize, 
              c * tileSize + tileSize, r * tileSize + tileSize
            );
            gradient.addColorStop(0, "#1e40af");
            gradient.addColorStop(1, "#1d4ed8");
            ctx.fillStyle = gradient;
            ctx.fillRect(c * tileSize + 3, r * tileSize + 3, tileSize - 6, tileSize - 6);
            
            ctx.fillStyle = "rgba(96, 165, 250, 0.3)";
            ctx.fillRect(c * tileSize + 4, r * tileSize + 4, tileSize - 8, 3);
          } else if (tile === 2) {
            ctx.fillStyle = "#f1f5f9";
            ctx.shadowBlur = 5;
            ctx.shadowColor = "#f1f5f9";
            ctx.beginPath();
            ctx.arc(
              c * tileSize + tileSize / 2,
              r * tileSize + tileSize / 2,
              3,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0;
          } else if (tile >= 3 && tile <= 6) {
            const powerUp = powerUpTypes[tile];
            const pulseSize = 8 + Math.sin(currentTime / 200) * 2;
            
            ctx.fillStyle = powerUp.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = powerUp.color;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(
              c * tileSize + tileSize / 2,
              r * tileSize + tileSize / 2,
              pulseSize + 4,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.globalAlpha = 1;
            
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(
              c * tileSize + tileSize / 2,
              r * tileSize + tileSize / 2,
              pulseSize,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = "#0f172a";
            ctx.font = "14px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(
              powerUp.icon,
              c * tileSize + tileSize / 2,
              r * tileSize + tileSize / 2
            );
          }
        }
      }
    }

    function canMoveTo(row, col) {
      if (row < 0 || col < 0 || row >= rows || col >= cols) return false;
      return currentMap[row][col] !== 1;
    }

    function movePacman() {
      const targetRow = pacman.row + pacman.nextDir.y;
      const targetCol = pacman.col + pacman.nextDir.x;
      if (canMoveTo(targetRow, targetCol)) {
        pacman.dir = { ...pacman.nextDir };
      }

      const newRow = pacman.row + pacman.dir.y;
      const newCol = pacman.col + pacman.dir.x;

      if (canMoveTo(newRow, newCol)) {
        pacman.row = newRow;
        pacman.col = newCol;

        const tile = currentMap[newRow][newCol];
        
        if (tile === 2) {
          currentMap[newRow][newCol] = 0;
          sounds.eatDot();
          totalDots--;
          combo++;
          comboTimer = 1000;
          
          if (totalDots === 0 && !gameOver) {
            levelUp();
          }
        } else if (tile >= 3 && tile <= 6) {
          const key = `${newRow}-${newCol}`;
          powerUpRespawn.collected.set(key, Date.now());
          currentMap[newRow][newCol] = 0;
          
          const powerUp = powerUpTypes[tile];
          
          pacman.powered = false;
          pacman.speed = 1;
          pacman.shield = false;
          pacman.freeze = false;
          
          switch(tile) {
            case 3:
              pacman.powered = true;
              pacman.powerTimer = powerUp.duration;
              ghostsEaten = 0;
              ghosts.forEach(ghost => ghost.color = "#3b82f6");
              messageEl.textContent = `‚ö° ${powerUp.name} activ√©e !`;
              break;
              
            case 4:
              pacman.speed = 2;
              pacman.powerTimer = powerUp.duration;
              messageEl.textContent = `üöÄ ${powerUp.name} activ√©e !`;
              break;
              
            case 5:
              pacman.shield = true;
              pacman.powerTimer = powerUp.duration;
              messageEl.textContent = `üõ°Ô∏è ${powerUp.name} activ√© !`;
              break;
              
            case 6:
              pacman.freeze = true;
              pacman.powerTimer = powerUp.duration;
              messageEl.textContent = `‚ùÑÔ∏è Fant√¥mes gel√©s !`;
              break;
          }
          
          sounds.eatPowerPellet();
          setTimeout(() => messageEl.textContent = "", 2000);
        }
      }
    }

    function levelUp() {
      gameOver = true;
      level++;
      const bonus = level * 500;
      addPoints(bonus);
      messageEl.textContent = `üéâ Niveau ${level - 1} termin√© ! Bonus: ${bonus} points`;
      
      setTimeout(() => {
        init();
      }, 3000);
    }

    function updatePacman(delta) {
      if (paused || gameOver) return;

      const currentDelay = pacmanStepDelay / pacman.speed;
      
      pacmanStepTimer += delta;
      if (pacmanStepTimer >= currentDelay) {
        pacmanStepTimer = 0;
        movePacman();
      }

      if (pacman.mouthOpening) {
        pacman.mouthAngle += 0.02 * pacman.speed;
        if (pacman.mouthAngle >= 0.45) pacman.mouthOpening = false;
      } else {
        pacman.mouthAngle -= 0.02 * pacman.speed;
        if (pacman.mouthAngle <= 0.1) pacman.mouthOpening = true;
      }

      if (pacman.powerTimer > 0) {
        pacman.powerTimer -= delta;
        
        if (pacman.powerTimer <= 0) {
          if (pacman.powered) {
            pacman.powered = false;
            ghosts.forEach(ghost => ghost.color = ghost.baseColor);
          }
          pacman.speed = 1;
          pacman.shield = false;
          pacman.freeze = false;
        }
      }

      if (comboTimer > 0) {
        comboTimer -= delta;
        if (comboTimer <= 0) {
          combo = 0;
        }
      }
    }

    function drawPacman() {
      const centerX = pacman.col * tileSize + tileSize / 2;
      const centerY = pacman.row * tileSize + tileSize / 2;

      let angleStart = 0;
      let angleEnd = Math.PI * 2;

      if (pacman.dir.x === 1) {
        angleStart = pacman.mouthAngle;
        angleEnd = Math.PI * 2 - pacman.mouthAngle;
      } else if (pacman.dir.x === -1) {
        angleStart = Math.PI + pacman.mouthAngle;
        angleEnd = Math.PI - pacman.mouthAngle;
      } else if (pacman.dir.y === -1) {
        angleStart = -Math.PI / 2 + pacman.mouthAngle;
        angleEnd = Math.PI * 1.5 - pacman.mouthAngle;
      } else if (pacman.dir.y === 1) {
        angleStart = Math.PI / 2 + pacman.mouthAngle;
        angleEnd = Math.PI / 2 - pacman.mouthAngle;
      }

      if (pacman.shield) {
        ctx.strokeStyle = "#3b82f6";
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#3b82f6";
        ctx.beginPath();
        ctx.arc(centerX, centerY, pacman.radius + 8, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      if (pacman.speed > 1) {
        ctx.strokeStyle = "#22c55e";
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.5;
        for (let i = 1; i <= 3; i++) {
          ctx.beginPath();
          ctx.arc(
            centerX - pacman.dir.x * i * 8,
            centerY - pacman.dir.y * i * 8,
            pacman.radius,
            angleStart,
            angleEnd
          );
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }

      if (pacman.powered) {
        ctx.shadowBlur = 25;
        ctx.shadowColor = "#facc15";
      }

      ctx.fillStyle = "#facc15";
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, pacman.radius, angleStart, angleEnd, false);
      ctx.closePath();
      ctx.fill();
      
      ctx.shadowBlur = 0;

      if (pacman.dir.x !== 0 || pacman.dir.y !== 0) {
        ctx.fillStyle = "#0f172a";
        const eyeX = centerX + (pacman.dir.x * 4) + (pacman.dir.y === -1 ? 0 : 3);
        const eyeY = centerY + (pacman.dir.y * 4) + (pacman.dir.x !== 0 ? -5 : 0);
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function getChaseTarget(ghost) {
      if (ghost.name === "Blinky") {
        return { row: pacman.row, col: pacman.col };
      } else if (ghost.name === "Pinky") {
        return { 
          row: pacman.row + pacman.dir.y * 4, 
          col: pacman.col + pacman.dir.x * 4 
        };
      } else if (ghost.name === "Inky") {
        return { 
          row: pacman.row + pacman.dir.y * 2, 
          col: pacman.col + pacman.dir.x * 2 
        };
      } else {
        const dist = Math.abs(ghost.row - pacman.row) + Math.abs(ghost.col - pacman.col);
        return dist > 8 ? { row: pacman.row, col: pacman.col } : ghost.scatterTarget;
      }
    }

    function getBestDirection(ghost, target) {
      const dirs = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 }
      ];

      let bestDir = ghost.dir;
      let bestDist = Infinity;

      for (const dir of dirs) {
        const newRow = ghost.row + dir.y;
        const newCol = ghost.col + dir.x;
        
        if (canMoveTo(newRow, newCol)) {
          const dist = Math.abs(newRow - target.row) + Math.abs(newCol - target.col);
          if (dist < bestDist) {
            bestDist = dist;
            bestDir = dir;
          }
        }
      }

      return bestDir;
    }

    function updateGhost(ghost, delta) {
      if (paused || gameOver) return;

      if (pacman.freeze) {
        return;
      }

      ghost.stepTimer += delta;
      const delay = pacman.powered ? ghostStepDelay * 1.5 : ghostStepDelay;
      
      if (ghost.stepTimer >= delay) {
        ghost.stepTimer = 0;
        
        let target;
        if (pacman.powered) {
          target = {
            row: ghost.row - (pacman.row - ghost.row),
            col: ghost.col - (pacman.col - ghost.col)
          };
        } else {
          target = getChaseTarget(ghost);
        }

        ghost.dir = getBestDirection(ghost, target);
        
        const newRow = ghost.row + ghost.dir.y;
        const newCol = ghost.col + ghost.dir.x;

        if (canMoveTo(newRow, newCol)) {
          ghost.row = newRow;
          ghost.col = newCol;
        }
      }

      if (!gameOver && ghost.row === pacman.row && ghost.col === pacman.col) {
        if (pacman.powered) {
          ghostsEaten++;
          sounds.eatGhost(ghostsEaten);
          ghost.row = 5;
          ghost.col = 7;
          ghost.color = ghost.baseColor;
        } else if (pacman.shield) {
          ghost.row = ghost.row - ghost.dir.y;
          ghost.col = ghost.col - ghost.dir.x;
          messageEl.textContent = "üõ°Ô∏è Bouclier activ√© !";
          setTimeout(() => messageEl.textContent = "", 1000);
        } else {
          lives--;
          updateLivesDisplay();
          
          if (lives <= 0) {
            gameOver = true;
            messageEl.textContent = "üíÄ GAME OVER ! Appuie sur üîÑ pour r√©essayer";
          } else {
            sounds.death();
            pacman.row = 5;
            pacman.col = 7;
            pacman.dir = { x: 0, y: 0 };
            pacman.nextDir = { x: 0, y: 0 };
            pacman.powered = false;
            pacman.speed = 1;
            pacman.shield = false;
            pacman.freeze = false;
            pacman.powerTimer = 0;
            
            const startPositions = [
              {row: 1, col: 1}, {row: 1, col: 12}, 
              {row: 9, col: 1}, {row: 9, col: 12}
            ];
            ghosts.forEach((g, i) => {
              g.row = startPositions[i].row;
              g.col = startPositions[i].col;
              g.stepTimer = 0;
              g.color = g.baseColor;
            });
          }
        }
      }
    }

    function drawGhost(ghost) {
      const x = ghost.col * tileSize + tileSize / 2;
      const y = ghost.row * tileSize + tileSize / 2;
      const r = tileSize / 2 - 4;

      if (pacman.freeze) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#a855f7";
        ctx.globalAlpha = 0.7;
      }

      ctx.fillStyle = ghost.color;
      if (pacman.powered && !pacman.freeze) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#3b82f6";
      }
      
      ctx.beginPath();
      ctx.arc(x, y - 4, r, Math.PI, 0);
      ctx.lineTo(x + r, y + r - 4);
      
      const waves = 3;
      for (let i = 0; i < waves; i++) {
        const waveX = x + r - (2 * r * (i + 1)) / (waves + 1);
        const waveY = y + r - 4 + (i % 2 === 0 ? 4 : -4);
        ctx.lineTo(waveX, waveY);
      }
      
      ctx.lineTo(x - r, y + r - 4);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;

      if (pacman.freeze) {
        ctx.fillStyle = "#a855f7";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#a855f7";
        ctx.fillText("‚ùÑÔ∏è", x, y - r - 8);
        ctx.shadowBlur = 0;
      }

      if ((!pacman.powered || pacman.powerTimer > 2000) && !pacman.freeze) {
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(x - 6, y - 6, 5, 0, Math.PI * 2);
        ctx.arc(x + 6, y - 6, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#0f172a";
        ctx.beginPath();
        ctx.arc(x - 6, y - 6, 3, 0, Math.PI * 2);
        ctx.arc(x + 6, y - 6, 3, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - 8, y - 8);
        ctx.lineTo(x - 4, y - 4);
        ctx.moveTo(x - 4, y - 8);
        ctx.lineTo(x - 8, y - 4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + 4, y - 8);
        ctx.lineTo(x + 8, y - 4);
        ctx.moveTo(x + 8, y - 8);
        ctx.lineTo(x + 4, y - 4);
        ctx.stroke();
      }
    }

    function loop(timestamp) {
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      updatePacman(delta);
      ghosts.forEach(ghost => updateGhost(ghost, delta));
      drawPacman();
      ghosts.forEach(ghost => drawGhost(ghost));

      requestAnimationFrame(loop);
    }

    // Contr√¥les tactiles et souris
    const upBtn = document.getElementById('up-btn');
    const downBtn = document.getElementById('down-btn');
    const leftBtn = document.getElementById('left-btn');
    const rightBtn = document.getElementById('right-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const restartBtn = document.getElementById('restart-btn');

    // Bouton Haut
    upBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      pacman.nextDir = { x: 0, y: -1 };
      if (gameOver) { lives = 3; init(); }
    });
    upBtn.addEventListener('click', (e) => {
      e.preventDefault();
      pacman.nextDir = { x: 0, y: -1 };
      if (gameOver) { lives = 3; init(); }
    });

    // Bouton Bas
    downBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      pacman.nextDir = { x: 0, y: 1 };
      if (gameOver) { lives = 3; init(); }
    });
    downBtn.addEventListener('click', (e) => {
      e.preventDefault();
      pacman.nextDir = { x: 0, y: 1 };
      if (gameOver) { lives = 3; init(); }
    });

    // Bouton Gauche
    leftBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      pacman.nextDir = { x: -1, y: 0 };
      if (gameOver) { lives = 3; init(); }
    });
    leftBtn.addEventListener('click', (e) => {
      e.preventDefault();
      pacman.nextDir = { x: -1, y: 0 };
      if (gameOver) { lives = 3; init(); }
    });

    // Bouton Droite
    rightBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      pacman.nextDir = { x: 1, y: 0 };
      if (gameOver) { lives = 3; init(); }
    });
    rightBtn.addEventListener('click', (e) => {
      e.preventDefault();
      pacman.nextDir = { x: 1, y: 0 };
      if (gameOver) { lives = 3; init(); }
    });

    // Bouton Pause
    pauseBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      paused = !paused;
      pauseOverlay.classList.toggle('active', paused);
    });
    pauseBtn.addEventListener('click', (e) => {
      e.preventDefault();
      paused = !paused;
      pauseOverlay.classList.toggle('active', paused);
    });

    // Bouton Recommencer
    restartBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      score = 0;
      level = 1;
      lives = 3;
      init();
    });
    restartBtn.addEventListener('click', (e) => {
      e.preventDefault();
      score = 0;
      level = 1;
      lives = 3;
      init();
    });

    // Support clavier pour desktop
    document.addEventListener("keydown", (e) => {
      if (e.key === " ") {
        e.preventDefault();
        paused = !paused;
        pauseOverlay.classList.toggle('active', paused);
        return;
      }

      if (e.key === "r" || e.key === "R") {
        e.preventDefault();
        score = 0;
        level = 1;
        lives = 3;
        init();
        return;
      }

      if (gameOver && ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
        lives = 3;
        init();
      }

      if (e.key === "ArrowLeft") {
        e.preventDefault();
        pacman.nextDir = { x: -1, y: 0 };
      } else if (e.key === "ArrowRight") {
        e.preventDefault();
        pacman.nextDir = { x: 1, y: 0 };
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        pacman.nextDir = { x: 0, y: -1 };
      } else if (e.key === "ArrowDown") {
        e.preventDefault();
        pacman.nextDir = { x: 0, y: 1 };
      }
    });

    // Initialisation
    highScoreEl.textContent = highScore;
    init();
    requestAnimationFrame(loop);
  </script>
</body>
</html>